# 实现一个挂载函数 mount function 

挂载函数作用：将虚拟DOM转成真实的DOM，并挂载到当前文档的DOM节点下。

```ts
// 注：类型名仅供字面理解，不准确
function h(tag: string, props: any, children: VNode[] | string): VNode {
	return {
		tag, props, children
	}
}

mout(vnode: VNode, container: HTMLElement) {
	const ele = vnode.el = document.createElement(vnode.tag);

	// 处理props
	// 分情况处理 dom property, attribute, 还是event listener
	// 这里简化为全是attribute
	if(vnode.props) {
		for ( const key in vnode.props ) {
			const value = vnode.props[key];
			ele.setAttribute(key, value);
		}
	}
	
	// 处理子组件
	// 这里将children简化为只有两种情况：string 或 VNode[]
	if (vnode.children) {
		if(typeof vnode.children === ‘string’) { ele.textContent = vnode.children }
		else {
			vnode.children.forEach((child) => {
				mout(child, ele);
			});
		}
	}

	// 挂在到dom节点
	container.appendChild(ele);
}

// 使用
// 创建虚拟dom
const vnode = h( ‘div’, { class: “m-10” }, [
	h( ‘div’, null, [‘hello, world’] );
]);

// 挂载到dom文档
mout(vnode, document.getElementById(‘app’));
```

mout 的作用是在开始时创建出那些还不存在的dom节点，当mout从无到有地创建出真实dom后，剩下的工作是尽可能多地利用已构建的虚拟dom，而不是一遍遍地重新创建真实dom，所以接下来一个很重要的函数 `patch` 用于虚拟dom变化后的对比、有限度地更新实际 dom 的操作

patch 函数接受两个参数：old-vnode 和 new-vnode，Evan You 形容这两种node 为 snapshot，patch 函数拿这两个 snapshot 做什么呢？

patch 会比较两个 snapshot 的差异，算出需要执行的最小的 DOM 更新操作，并执行更新。即当调用patch(oldVnode, newVnode) 时，会以最少的 DOM 操作实现页面更新。

如何比较：
	- 缓存：在vnode上缓存一份（参照它创建出来的）真实DOM，以供比较

```js
/**
*@param n1: old virtual node
*@param n2: new virtual node
*/
function patch(n1, n2) {}

const vnode2 = h( ‘div’, { class: “red” }, [
	h( ‘div’, null, [‘yes, what’s up’] );
]);

patch(vnode, vnode2);
``` 